/* ABI Definitions */
#define function name() view returns(string)
#define function symbol() view returns(string)
#define function decimals() view returns(uint8)

#define function totalSupply() view returns(uint256)
#define function balanceOf(address) view returns(uint256)
#define function allowance(address,address) view returns(uint256)

#define function approve(address,uint256) nonpayable returns(bool)
#define function transfer(address,uint256) nonpayable returns(bool)
#define function transferFrom(address,address,uint256) nonpayable returns(bool)

#define event Approval(address,address,uint256)
#define event Transfer(address,address,uint256)

#define function deposit() payable returns()
#define function withdraw(uint256) nonpayable returns()

#define event Deposit(address,uint256)
#define event Withdrawl(address,uint256)

/* Macro Definitions */
#define macro NAME() = takes(0) returns(0) {
    // store string offset in memory
    0x20                                        // [0x20]
    0x00                                        // [0x00, 0x20]
    mstore                                      // []

    // store the string length concatenated with the string in memory
    __RIGHTPAD(0x0d57726170706564204574686572)  // [13 . "Wrapped Ether"]
    0x3f                                        // [0x20, 13 . "Wrapped Ether"]
    mstore                                      // []

    // return the string
    0x60                                        // [0x60]
    0x00                                        // [0x00, 0x60]
    return                                      // []
}

#define macro SYMBOL() = takes(0) returns(0) {
    // store string offset in memory
    0x20                        // [0x20]
    0x00                        // [0x00, 0x20]
    mstore                      // []

    // store the string length concatenated with the string in memory
    __RIGHTPAD(0x0457455448)    // [4 . "WETH"]
    0x3f                        // [0x20, 4 . "WETH"]
    mstore

    // return the string
    0x60                        // [0x60]
    0x00                        // [0x00, 0x60]
    return                      // []
}

#define macro DECIMALS() = takes(0) returns(0) {
    // store the decimals in memory
    0x12    // [0x12]
    0x00    // [0x00, 0x12]
    mstore  // []

    // return the decimals
    0x20    // [0x20]
    0x00    // [0x00, 0x20]
    return  // []
}

#define macro TOTAL_SUPPLY() = takes(0) returns(0) {
    // store current ether balance in memory
    selfbalance // [selfbalance]
    0x00        // [0x00, selfbalance]
    mstore      // []

    // return the current ether balance
    0x20        // [0x20]
    0x00        // [0x00, 0x20]
    return      // []
}

#define macro BALANCE_OF() = takes(0) returns(0) {
    // load the target from calldata
    0x04            // [0x04]
    calldataload    // [target]

    // validate target
    dup1            // [target, target]
    0xa0            // [0xa0, target, target]
    shr             // [target>>0xa0, target]
    error           // [error, target>>0xa0, target]
    jumpi           // [target]

    // calculate the storage slot where token balance is stored
    0x00            // [0x00, target]
    mstore          // []
    0x20            // [0x20]
    0x00            // [0x00, 0x20]
    sha3            // [slot]

    // load token balance from storage and store in memory
    sload           // [token_balance]
    0x00            // [0x00, token_balance]
    mstore          // []

    // return the token balance
    0x20            // [0x20]
    0x00            // [0x00, 0x20]
    return          // []
}

#define macro ALLOWANCE() = takes(0) returns(0) {
    // load the owner from calldataload
    0x04            // [0x04]
    calldataload    // [owner]

    // validate the owner
    dup1            // [owner, owner]
    0xa0            // [0xa0, owner, owner]
    shr             // [owner>>0xa0, owner]
    error           // [error, owner>>0xa0, owner]
    jumpi           // [owner]

    // load the spender from calldata
    0x24            // [0x24, owner]
    calldataload    // [spender, owner]

    // validate the spender
    dup1            // [spender, spender, owner]
    0xa0            // [0xa0, spender, spender, owner]
    shr             // [spender>>0xa0, spender, owner]
    error           // [error, spender>>0xa0, spender, owner]
    jumpi           // [spender, owner]

    // calculate the storage slot where allowance is stored
    0x00            // [0x00, spender, owner]
    mstore          // [owner]
    0x20            // [0x20, owner]
    mstore          // []
    0x40            // [0x40]
    0x00            // [0x00, 0x40]
    sha3            // [slot]

    // load allowance from storage and store in memory
    sload           // [allowance]
    0x00            // [0x00, allowance]
    mstore          // []

    // return the token allowance
    0x20            // [0x20]
    0x00            // [0x00, 0x20]
    return          // []
}

#define macro APPROVE() = takes(0) returns(0) {
    // load the spender from calldata
    0x20                    // [0x20]
    0x04                    // [0x04, 0x20]
    0x00                    // [0x00, 0x04, 0x20]
    calldatacopy            // []
    0x00                    // [0x00]
    mload                   // [spender]

    // validate the spender
    dup1                    // [spender, spender]
    0xa0                    // [0xa0, spender, spender]
    shr                     // [spender>>0xa0, spender]
    error                   // [error, spender>>0xa0, spender]
    jumpi                   // [spender]

    // calculate the storage slot where allowance is stored
    caller                  // [owner, spender]
    0x20                    // [0x20, owner, spender]
    mstore                  // [spender]
    0x40                    // [0x40, spender]
    0x00                    // [0x00, 0x40, spender]
    sha3                    // [slot, spender]

    // load the approval amount from calldata
    0x20                    // [0x20, slot, spender]
    0x24                    // [0x24, 0x20, slot, spender]
    0x00                    // [0x00, 0x24, 0x20, slot, spender]
    calldatacopy            // [slot, spender]
    0x00                    // [0x00, slot, spender]
    mload                   // [amount, slot, spender]

    // store amount in storage
    swap1                   // [slot, amount, spender]
    sstore                  // [spender]

    // log Approval
    caller                  // [owner, spender]
    __EVENT_HASH(Approval)  // [approval_sig, owner, spender]
    0x20                    // [0x20, approval_sig, owner, spender]
    0x00                    // [0x00, 0x20, approval_sig, owner, spender]
    log3                    // []

    // return true
    0x01                    // [0x01]
    0x00                    // [0x00, 0x01]
    mstore                  // []
    0x20                    // [0x20]
    0x00                    // [0x00, 0x20]
    return                  // []
}

#define macro MAIN() = takes(0) returns(0) {
    0x00 calldataload 0xe0 shr                          // [selector]

    dup1 __FUNC_SIG(name) eq name jumpi                 // [selector]
    dup1 __FUNC_SIG(symbol) eq symbol jumpi             // [selector]
    dup1 __FUNC_SIG(decimals) eq decimals jumpi         // [selector]

    dup1 __FUNC_SIG(totalSupply) eq totalSupply jumpi   // [selector]
    dup1 __FUNC_SIG(balanceOf) eq balanceOf jumpi       // [selector]
    dup1 __FUNC_SIG(allowance) eq allowance jumpi       // [selector]

    __FUNC_SIG(approve) eq approve jumpi                // []

    error:
        0x00 dup1 revert                                // []

    name:
        NAME()
    symbol:
        SYMBOL()
    decimals:
        DECIMALS()
    totalSupply:
        TOTAL_SUPPLY()
    balanceOf:
        BALANCE_OF()
    allowance:
        ALLOWANCE()
    approve:
        APPROVE()
}
